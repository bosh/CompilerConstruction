grammar Pseudocal
  start_symbol :Program
  
  rule Program
    "Program" id ";" [TypeDefinitions] [VariableDeclarations] [SubprogramDeclarations] CompoundStatement "."
  endrule
  rule TypeDefinitions
    "type" TypeDefinition ";" {TypeDefinition ";"}
  endrule
  rule VariableDeclarations
    "var" VariableDeclaration ";" {VariableDeclaration ";"}
  endrule
  rule SubprogramDeclarations
    {(ProcedureDeclaration / FunctionDeclaration) ";"}
  endrule
  rule TypeDefinition
    id "=" Type
  endrule
  rule VariableDeclaration
    IdentifierList ":" Type
  endrule
  rule ProcedureDeclaration
    "Procedure" id "(" FormalParameterList ")" ";" ( Block / "forward" )
  endrule
  rule FunctionDeclaration
    "function" id "(" FormalParameterList ")" ":" ResultType ";" ( Block / "forward" )
  endrule
  rule FormalParameterList
    [IdentifierList ":" Type {";" IdentifierList ":" Type}]
  endrule
  rule Block
    [VariableDeclarations] CompoundStatement
  endrule
  rule CompoundStatement
    "begin" Statement "end"
  endrule
  rule StatementSequence
    Statement {";" Statement}
  endrule
  rule Statement
    (SimpleStatement / StructuredStatement)
  endrule
  rule SimpleStatement
    [(AssignmentStatement / ProcedureStatement)]
  endrule
  rule AssignmentStatement 
    Variable ":=" Expression
  endrule
  rule ProcedureStatement
    id "(" ActualParameterList ")"
  endrule
  rule StructuredStatement
    (MatchedStatement / OpenStatement)
  endrule
  rule MatchedStatement
    ("if" Expression "then" MatchedStatement "else" MatchedStatement
    / CompoundStatement
    / "while" Expression "do" MatchedStatement
    / "for" id ":=" Expression "to" Expression "do" MatchedStatement
    )
  endrule
  rule OpenStatement
    ("if" Expression "then" Statement
    / "if" Expression "then" MatchedStatement "else" OpenStatement
    / "while" Expression "do" OpenStatement
    / "for" id ":=" Expression "to" Expression "do" OpenStatement
    )
  endrule
  rule Type
    (id / "array" "[" Constant ".." Constant "]" "of" Type / "record" FieldList "end")
  endrule
  rule ResultType
    id
  endrule
  rule FieldList
    [IdentifierList ":" Type {";" IdentifierList ":" Type}]
  endrule
  rule Constant
    [Sign] int
  endrule
  rule Expression
    SimpleExpression [RelationalOp SimpleExpression]
  endrule
  rule RelationalOp
    ("=" / "<" / "<=" / ">" / ">=" / "<>" / "=")
  endrule
  rule SimpleExpression
    [Sign] Term {AddOp Term}
  endrule
  rule AddOp
    ("+" / "-" / "or")
  endrule
  rule Term
    Factor {MulOp Factor}
  endrule
  rule MulOp
    ("*" / "div" / "mod" / "and")
  endrule
  rule Factor
    (int / str / Variable / FunctionReference / "not" Factor / "("Expression")")
  endrule
  rule FunctionReference
    id "(" ActualParameterList ")"
  endrule
  rule Variable
    id ComponentSelection
  endrule
  rule ComponentSelection
    [("." id / "[" Expression "]" ) ComponentSelection]
  endrule
  rule ActualParameterList
    [Expression {"," Expression}]
  endrule
  rule IdentifierList
    id {"," id}
  endrule
  rule Sign
    ("+" / "-")
  endrule
endgrammar
##########
#  rule id; :type; endrule
#  rule int; :type endrule
#  rule string; :type endrule
#  in each of these three cases, grammar[:id|:int|:str] will be undefined, and thus you try Token.type instead of Token.value